# Notification Service Implementation Guide

## Overview
This document provides a complete guide to implementing the notification service and removing the old task event logic.

## Architecture

### Components
1. **Notification Service** - Standalone service that:
   - Consumes notification events from RabbitMQ
   - Stores notifications in database
   - Provides gRPC API for notification operations

2. **API Gateway** - Provides HTTP/REST endpoints and WebSocket integration

3. **Task Service** - Publishes notification events for task and comment operations

## Database Schema

### Notifications Table
```sql
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    organization_id UUID NOT NULL,
    trigger_user_id UUID NOT NULL,
    type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT,
    data JSONB,
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMP,
    
    INDEX idx_user_read (user_id, is_read),
    INDEX idx_user_created (user_id, created_at DESC),
    INDEX idx_organization (organization_id),
    INDEX idx_type (type),
    INDEX idx_deleted (deleted_at)
);
```

## Implementation Steps

### Step 1: Core Infrastructure (COMPLETED âœ…)
- [x] Created notification event contracts in `shared/contracts/notification.go`
- [x] Created notification publisher in `shared/messaging/notification_publisher.go`
- [x] Created notification model in `services/notification-service/internal/models/notification.go`

### Step 2: Notification Service Implementation

#### 2.1 Create Protobuf Definitions
File: `proto/notification/v1/notification.proto`

```protobuf
syntax = "proto3";

package notification.v1;

option go_package = "github.com/aliirah/task-flow/shared/proto/notification/v1;notificationpb";

import "google/protobuf/timestamp.proto";

service NotificationService {
  rpc ListNotifications(ListNotificationsRequest) returns (ListNotificationsResponse);
  rpc MarkAsRead(MarkAsReadRequest) returns (MarkAsReadResponse);
  rpc MarkAllAsRead(MarkAllAsReadRequest) returns (MarkAllAsReadResponse);
  rpc DeleteNotification(DeleteNotificationRequest) returns (DeleteNotificationResponse);
  rpc GetUnreadCount(GetUnreadCountRequest) returns (GetUnreadCountResponse);
}

message Notification {
  string id = 1;
  string user_id = 2;
  string organization_id = 3;
  string trigger_user_id = 4;
  string type = 5;
  string entity_type = 6;
  string entity_id = 7;
  string title = 8;
  string message = 9;
  string data = 10; // JSON string
  bool is_read = 11;
  google.protobuf.Timestamp read_at = 12;
  google.protobuf.Timestamp created_at = 13;
}

message ListNotificationsRequest {
  int32 page = 1;
  int32 limit = 2;
  bool unread_only = 3;
}

message ListNotificationsResponse {
  repeated Notification items = 1;
  int32 total = 2;
  bool has_more = 3;
}

message MarkAsReadRequest {
  string id = 1;
}

message MarkAsReadResponse {
  bool success = 1;
}

message MarkAllAsReadRequest {}

message MarkAllAsReadResponse {
  int32 count = 1;
}

message DeleteNotificationRequest {
  string id = 1;
}

message DeleteNotificationResponse {
  bool success = 1;
}

message GetUnreadCountRequest {}

message GetUnreadCountResponse {
  int32 count = 1;
}
```

#### 2.2 Service Layer
File: `services/notification-service/internal/service/notification_service.go`

Handles all persistence and business logic for notifications:
- Creates notifications generated by RabbitMQ consumer
- Lists notifications with pagination and `hasMore` calculation
- Marks single or multiple notifications as read
- Deletes notifications scoped by user
- Computes unread count for quick badge updates

#### 2.3 Event Consumer
File: `services/notification-service/internal/event/notification_consumer.go`

Consumes from RabbitMQ `notifications` queue and creates notifications based on:
- Recipients list from the event
- Notification type (task_created, comment_mentioned, etc.)
- Determines notification title and message based on event data

### Step 3: Task Service Integration

#### 3.1 Update Task Service to Publish Notification Events

Modify `services/task-service/internal/service/task_service.go`:

**For CreateTask:**
```go
// After task creation
recipients := []string{}
if assignee != nil && assignee.Id != triggeredBy.UserID {
    recipients = append(recipients, assignee.Id)
}
if reporter != nil && reporter.Id != triggeredBy.UserID && reporter.Id != assignee.GetId() {
    recipients = append(recipients, reporter.Id)
}

notifData := &contracts.TaskNotificationData{
    TaskID: task.ID.String(),
    Title: task.Title,
    Status: string(task.Status),
    Priority: string(task.Priority),
    // ... other fields
}

s.notifPublisher.PublishTaskCreated(ctx, task.OrganizationID.String(), triggeredBy.UserID, recipients, notifData)
```

**For UpdateTask:**
Similar logic with tracking changes

**For DeleteTask:**
Notify assignee and reporter

#### 3.2 Update Comment Service to Publish Notification Events

Modify `services/task-service/internal/service/comment_service.go`:

**For CreateComment:**
- If has parent: notify parent comment author
- If has mentions: notify mentioned users
- Notify task assignee and reporter (if not trigger user)

**For UpdateComment:**
- If mentions changed: notify newly mentioned users

**For DeleteComment:**
- Optionally notify if needed

### Step 4: API Gateway Integration

#### 4.1 Add Notification HTTP Handler
File: `services/api-gateway/internal/handler/http/notification_http_handler.go`

Endpoints:
- `GET /api/notifications` - List notifications
- `GET /api/notifications/unread-count` - Get unread count
- `PATCH /api/notifications/:id/read` - Mark as read
- `POST /api/notifications/read-all` - Mark all as read
- `DELETE /api/notifications/:id` - Delete notification

#### 4.2 Update WebSocket to Send Notifications
File: `services/api-gateway/internal/handler/ws/websocket_handler.go`

- Create notification consumer in api-gateway
- When notification is created, send to user's WebSocket connection
- Send notification with type "notification"

### Step 5: Cleanup Old Logic

#### 5.1 Remove from Task Service
- Delete `services/task-service/internal/event/task_publisher.go`
- Remove TaskCreated/TaskUpdated publisher calls from `task_service.go`
- Remove old publisher initialization

#### 5.2 Remove from API Gateway
- Delete `services/api-gateway/internal/event/task_consumer.go`
- Remove WebSocket task event handling
- Remove old consumer initialization

#### 5.3 Remove from Shared
- Remove TaskCreatedEvent and TaskUpdatedEvent from `shared/contracts/amqp.go`
- Remove task event constants

#### 5.4 Clean Frontend
- Remove task event types from `web/client/src/lib/types/ws.ts`
- Remove task event handlers from WebSocket hook
- Remove task event modal/toast logic

### Step 6: Frontend Notification UI

#### 6.1 Create Notification API Client
File: `web/client/src/lib/api/notification.ts`

```typescript
export const notificationApi = {
  list: (params?: { page?: number; limit?: number; unreadOnly?: boolean }) =>
    apiClient<NotificationListResponse>(`/api/notifications?${new URLSearchParams(params)}`),
  
  markAsRead: (id: string) =>
    apiClient(`/api/notifications/${id}/read`, { method: 'PATCH' }),
  
  markAllAsRead: () =>
    apiClient(`/api/notifications/read-all`, { method: 'POST' }),
  
  delete: (id: string) =>
    apiClient(`/api/notifications/${id}`, { method: 'DELETE' }),
  
  getUnreadCount: () =>
    apiClient<{ count: number }>(`/api/notifications/unread-count`),
}
```

#### 6.2 Create Notification Components
- `web/client/src/components/notifications/notification-bell.tsx` - Header bell icon with badge
- `web/client/src/components/notifications/notification-dropdown.tsx` - Dropdown with list
- `web/client/src/components/notifications/notification-item.tsx` - Individual notification

#### 6.3 WebSocket Integration
- Listen for "notification" events
- Add to notification list
- Update unread count
- Show toast for important notifications

#### 6.4 Auto Mark as Read
- When user clicks notification -> navigate to task -> mark as read
- When user views task page -> mark related notifications as read

## Testing Checklist

- [ ] Task created -> assignee and reporter receive notification
- [ ] Task updated -> assignee and reporter receive notification
- [ ] Task deleted -> assignee and reporter receive notification
- [ ] Comment created -> task participants receive notification
- [ ] Comment with mention -> mentioned users receive notification
- [ ] Comment reply -> parent comment author receives notification
- [ ] Mark notification as read works
- [ ] Mark all as read works
- [ ] Delete notification works
- [ ] Unread count updates in real-time
- [ ] WebSocket delivers notifications instantly
- [ ] Clicking notification navigates to task and marks as read
- [ ] Old task event logic completely removed

## Deployment Order

1. Deploy shared contracts and messaging updates
2. Deploy notification-service
3. Deploy task-service with notification publishers
4. Deploy api-gateway with notification endpoints
5. Deploy frontend with notification UI
6. Remove old task event queues from RabbitMQ
7. Clean up old code

## Configuration

### Environment Variables

**Notification Service:**
```env
DATABASE_URL=postgresql://...
RABBITMQ_URL=amqp://...
GRPC_PORT=50055
```

**API Gateway:**
```env
NOTIFICATION_SERVICE_URL=localhost:50055
```

## Migration Script

```sql
-- Run this to create notifications table
CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    organization_id UUID NOT NULL,
    trigger_user_id UUID NOT NULL,
    type VARCHAR(50) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    entity_id UUID NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT,
    data JSONB,
    is_read BOOLEAN DEFAULT FALSE NOT NULL,
    read_at TIMESTAMP,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
    deleted_at TIMESTAMP
);

CREATE INDEX idx_notifications_user_read ON notifications(user_id, is_read) WHERE deleted_at IS NULL;
CREATE INDEX idx_notifications_user_created ON notifications(user_id, created_at DESC) WHERE deleted_at IS NULL;
CREATE INDEX idx_notifications_organization ON notifications(organization_id) WHERE deleted_at IS NULL;
CREATE INDEX idx_notifications_type ON notifications(type) WHERE deleted_at IS NULL;
```

## Next Steps

This is a large refactoring. I recommend:
1. Implement notification service with basic CRUD
2. Add notification publishers to task-service
3. Test notification creation
4. Implement API gateway endpoints
5. Build frontend UI
6. Remove old logic once new system is verified

Would you like me to implement any specific part of this in detail?
